rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function uid() {
      return isSignedIn() ? request.auth.uid : null;
    }

    function isGroupMember(groupId) {
      return isSignedIn()
        && exists(/databases/$(database)/documents/groupChats/$(groupId))
        && get(/databases/$(database)/documents/groupChats/$(groupId)).data.members is list
        && get(/databases/$(database)/documents/groupChats/$(groupId)).data.members.hasAny([uid()]);
    }

    function isGroupAdmin(groupId) {
      return isSignedIn()
        && exists(/databases/$(database)/documents/groupChats/$(groupId))
        && get(/databases/$(database)/documents/groupChats/$(groupId)).data.admins is list
        && get(/databases/$(database)/documents/groupChats/$(groupId)).data.admins.hasAny([uid()]);
    }
    
    // Notifications collection
    match /notifications/{notificationId} {
    
      // Only the receiver can read their notifications
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      
      //Allow the user to update their notification read status
      allow update: if request.auth != null && resource.data.userId == request.auth.uid;

      // Any authenticated user can write (create notifications for others)
      allow create: if request.auth != null;

			//Deletion of notifications
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }
    
    // Posts are public, but only authenticated users can update/create
    match /posts/{postId} {
      allow read: if true;
      allow write: if request.auth != null;
    }


    // Users profile docs
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.resource.id == uid();
      allow update: if isSignedIn() && userId == uid();
      allow delete: if false;
    }

    // One-to-one messages stored at root: /messages/{messageId}
    match /messages/{messageId} {
      // Read allowed if caller is a participant OR the sender/recipient (supports legacy docs without participants field)
      allow read: if isSignedIn() && (
        (resource.data.participants is list && resource.data.participants.hasAny([uid()])) ||
        resource.data.senderId == uid() || resource.data.recipientId == uid()
      );

      // Sender creates a message with required fields and valid types
      allow create: if isSignedIn()
        && request.resource.data.senderId == uid()
        && request.resource.data.recipientId is string
        && request.resource.data.text is string
        && (request.resource.data.createdAt is timestamp || request.resource.data.createdAt == request.time)
        && request.resource.data.read is bool
        && request.resource.data.participants is list
        && request.resource.data.participants.hasAll([uid(), request.resource.data.recipientId]);

      // Only recipient can toggle read flag; no other changes allowed
      allow update: if isSignedIn()
        && resource.data.recipientId == uid()
        && request.resource.data.diff(resource.data).changedKeys().size() == 1
        && request.resource.data.diff(resource.data).changedKeys().hasAll(['read'])
        && request.resource.data.read is bool;

      allow delete: if false;
    }

    // Group chats: /groupChats/{groupId} and subcollection /messages
    match /groupChats/{groupId} {
      // Read group doc if the caller is a member (use resource directly to avoid extra get() reads)
      allow read: if isSignedIn() && resource.data.members is list && resource.data.members.hasAny([uid()]);

      // Group creation: creator must include themselves in members and admins
      allow create: if isSignedIn()
        && request.resource.data.name is string
        && request.resource.data.members is list
        && request.resource.data.admins is list
        && request.resource.data.createdBy == uid()
        && request.resource.data.members.hasAny([uid()])
        && request.resource.data.admins.hasAny([uid()])
        && (request.resource.data.createdAt is timestamp || request.resource.data.createdAt == request.time);

      // Only admins can update group metadata (e.g., name, members, admins)
      allow update: if isGroupAdmin(groupId);

      allow delete: if false;

      // Group messages subcollection
      match /messages/{messageId} {
        allow read: if isGroupMember(groupId);

        // Only group members can post; enforce required fields
        allow create: if isGroupMember(groupId)
          && request.resource.data.senderId == uid()
          && request.resource.data.text is string
          && (request.resource.data.createdAt is timestamp || request.resource.data.createdAt == request.time)
          && request.resource.data.readBy is list;

        // Only allow adding caller's uid to readBy; no other field changes
        allow update: if isGroupMember(groupId)
          && request.resource.data.readBy is list
          && request.resource.data.diff(resource.data).changedKeys().size() == 1
          && request.resource.data.diff(resource.data).changedKeys().hasAll(['readBy'])
          && !resource.data.readBy.hasAny([uid()])
          && request.resource.data.readBy.hasAny([uid()])
          && request.resource.data.readBy.size() >= resource.data.readBy.size();

        allow delete: if false;
      }
    }
  }
}